VerseCraft-Clean canonical systems and navigation map. Source build: VerseCraft-Clean-main.zip. This document defines authoritative current behavior for systems, navigation, screen control, DOM ownership, and data flow. It is canonical unless explicitly superseded.

The high-level control spine is simple and rigid: screen_registry.json defines what screens exist and which assets they use, screen-manager.js controls screen visibility, CSS loading, and hitbox injection, input.js converts taps into go() calls, and all other systems react passively to the vc:screenchange event.

index.html statically defines every screen as a section element with class “screen” and a data-screen attribute. No screens are created dynamically. Every screen contains exactly one div with class hitbox-layer. This div is always present and is the only location where navigation hitboxes are injected.

src/bootstrap.js initializes the application. Initialization order is fixed and significant. It runs init_debug_ui first, then init_input, then init_library_labels, then init_audio_manager. If the URL contains ?debug=1, debug_tools is dynamically imported. Next, init_launcher_labels is dynamically imported, followed by init_launcher_content, then init_story_runtime. Finally, init_screen_manager runs, which loads screen_registry.json and navigates to the configured start_screen. No navigation occurs before the screen manager initializes.

All navigation authority lives in sec/screen_registry.json. Each screen entry defines a CSS file path, a hitbox JSON path, and an optional controller field which is currently unused and always null. The registry also supports special navigation tokens. The token last_library resolves at runtime to the most recently visited library screen among library, library1, or library2. The token last_story resolves to the most recently visited story_* screen. These values are stored in memory only and are not persisted.

Screen transitions are handled entirely by core/screen-manager.js. When go(screen_id) is called, the screen manager resolves any special tokens, removes the is-active class from all screens, loads the target screen’s CSS file if it has not already been loaded, and applies the is-active class to the target screen. It sets documentElement.dataset.screen and body.dataset.screen to the active screen id. It then injects hitboxes by loading the screen’s hitbox JSON, clearing only the active screen’s hitbox-layer, and creating button elements with class hitbox using percentage-based geometry. Each hitbox button includes data-action, data-arg, and data-hitbox-id attributes. After injection, the screen manager dispatches a CustomEvent named vc:screenchange with the active screen id in the detail payload. Screen CSS is cumulative by design and never unloaded.

Input handling is centralized in core/input.js. It uses global delegated listeners for pointerup and click events. When an interaction occurs, it searches for the closest ancestor with class hitbox. If found, it reads the data-action and data-arg attributes. The only supported action is “go”, which triggers a call to go(arg). All navigation in VerseCraft-Clean happens exclusively through hitbox interactions.

DOM ownership rules are strict. Static DOM consists only of the screen sections and their hitbox-layer divs. The screen manager owns all hitbox buttons. Overlay systems may inject ui-layer elements such as library-title-layer, launcher-label-layer, launcher-content-layer, and story-runtime-layer, but these overlays are non-authoritative and must never control navigation directly. Story runtime may also create choice buttons with ids choice0 through choice3 if they are not present in the screen markup.

Overlay systems are listeners only and respond to vc:screenchange. The library labels system runs on library, library1, and library2 screens and aligns visible story titles to slot_* hitboxes. The launcher labels system runs on launcher_* screens and renders readable text aligned to hitboxes; it may warn if expected hitbox ids are missing but does not fail. Launcher content runs on launcher_* screens and injects cover art and blurb text using catalog.json with a fallback mapping. Story runtime runs on story_* screens, resolves the story JSON via the catalog system, renders narrative content, and manages choices internally. Story choices do not use the hitbox system and do not call go(); they dispatch internal story events and trigger re-rendering within the same screen. Audio manager listens to vc:screenchange and maps screens to background tracks, unlocking audio only after a user gesture for iOS compatibility. Debug UI activates only when ?debug=1 is present and does not alter runtime behavior.

Logical navigation flow follows a consistent pattern. splash leads to tos, tos leads to menu, and menu leads to library or settings. Library screens paginate between library, library1, and library2. Library screens lead to launcher_* screens. Launcher_* screens lead to story_* screens. Story screens can navigate to character_* or inventory_* screens and return either to last_story or directly to a specific story screen depending on the hitbox configuration. Story screens can also exit to last_library. Settings screens form a closed loop that always returns to menu.

Known inconsistencies exist but do not currently break the build. Some character and inventory screens return to explicit story_* screens while others use last_story. Some launcher hitbox files do not define all hitbox ids expected by the launcher label overlay. Story choice navigation bypasses the hitbox system entirely.

Canonical rules are locked as follows. screen_registry.json is the only navigation authority. Screens are static and never created dynamically. All navigation is driven by hitboxes. Overlay systems must remain passive and event-driven. CSS is cumulative and screen-scoped. vc:screenchange is the global synchronization event for all systems.
